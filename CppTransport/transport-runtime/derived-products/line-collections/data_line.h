//
// Created by David Seery on 21/05/2014.
// --@@
// Copyright (c) 2016 University of Sussex. All rights reserved.
//
// This file is part of the CppTransport platform.
//
// CppTransport is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// CppTransport is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CppTransport.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//


#ifndef CPPTRANSPORT_DATA_LINE_H
#define CPPTRANSPORT_DATA_LINE_H

#include <vector>
#include <string>
#include <algorithm>

#include "transport-runtime/messages.h"
#include "transport-runtime/exceptions.h"

#include "transport-runtime/derived-products/line-collections/line_values.h"

#include "transport-runtime/utilities/spline1d.h"


namespace transport
  {

    namespace derived_data
      {

        enum class data_storage_type
          {
            raw, splined, derivative, spectral_index
          };

        //! A data_line is a data line suitable for use by a derived output.
        //! data_lines are generated by the different content generators, eg field_time_series, etc.
        //! It consists of a set of (x,y) data-point pairs, and associated metadata
        template <typename number>
        class data_line
          {

            // TYPES

          public:

            //! data point
            using point = std::pair<double, number>;

            //! list of points
            using point_list = std::vector<point>;


            // CONSTRUCTOR, DESTRUCTOR

          public:

		        //! Construct a dataline object from a sequence of axis and data points.
		        //! If spectral_index is true, the supplied data points are splined and the spectral index
		        //! is computed instead. These values are stored in the data line, and the original
		        //! points are thrown away.
            data_line(content_group_name_set g, axis_value at, value_type vt,
                      const std::vector<double>& a, const std::vector<number>& d,
                      std::string Ll, std::string nLl,
                      slave_message_buffer& msg, data_storage_type type=data_storage_type::raw);

            //! Construct a dataline object from a sequence of axis and data points
            //! convenience version that automatically wraps a string representing a single-item
            //! provenance list into a content_group_name_set.
            //! If spectral_index is true, the supplied data points are splined and the spectral index
            //! is computed instead. These values are stored in the data line, and the original
            //! points are thrown away.
            data_line(std::string g, axis_value at, value_type vt,
                      const std::vector<double>& a, const std::vector<number>& d,
                      std::string Ll, std::string nLl,
                      slave_message_buffer& msg, data_storage_type type=data_storage_type::raw)
              : data_line(content_group_name_set{g}, at, vt, a, d, std::move(Ll), std::move(nLl), msg, type)
              {
              }

            //! destructor is default
            ~data_line() = default;


            // GET DATA

          public:

            //! Get number of sample points
            unsigned int size() const { return(this->data.size()); }

            //! Get LaTeX label
            const std::string& get_LaTeX_label() const { return(this->LaTeX_label); }

		        //! Get non-LaTeX label
		        const std::string& get_non_LaTeX_label() const { return(this->non_LaTeX_label); }

		        //! Get data points
		        const point_list& get_data_points() const { return(this->data); }

		        //! Get x value-type
		        axis_value get_axis_value() const { return(this->x_type); }

		        //! Get y value-type
		        value_type get_value_type() const { return(this->y_type); }

            //! Get type of data - scattered or continuous?
		        data_line_type get_data_line_type() const { return(this->data_type); }

		        //! Set type of data
		        void set_data_line_type(data_line_type t) { this->data_type = t; }

            //! Get parent content groups
            const content_group_name_set& get_parent_groups() const { return(this->groups); }


            // INTERNAL API

          protected:

            //! zip a pair of lists representing x,y coordinates into a point_list
            point_list zip(const std::vector<double>& a, const std::vector<number>& d);


            // INTERNAL DATA

          protected:

            // ENVIRONMENT

            //! message buffer
            slave_message_buffer& messages;


            // DATA LINE

            //! source content group(s)
            content_group_name_set groups;

		        //! axis type
		        const axis_value x_type;

		        //! value type
		        value_type y_type;

		        //! vector of data
		        point_list data;

		        //! type of data - is it scattered or continuous?
		        data_line_type data_type;


            // LABELS

            //! non-LaTeX label
            const std::string LaTeX_label;

		        //! non-LaTeX label
						const std::string non_LaTeX_label;

          };


        //! container type for a group of data lines. Remember that a data_line<> instance is the output
        //! produced by a derived content generator, such as field_time_series<> or twopf_wavenumber_series<>.
        //! Each data_line<> consists of a set of (x,y) data-point pairs and associated metadata
        template <typename number>
        using data_line_set = std::list< data_line<number> >;


        template <typename number>
        data_line<number>::data_line(content_group_name_set g, axis_value at, value_type vt,
                                     const std::vector<double>& a, const std::vector<number>& d,
                                     std::string Ll, std::string nLl,
                                     slave_message_buffer& msg, data_storage_type type)
	        : groups(std::move(g)),
            x_type(at),
	          LaTeX_label(std::move(Ll)),
	          non_LaTeX_label(std::move(nLl)),
            data_type(data_line_type::continuous_data),
            messages(msg)
          {
            if(a.size() != d.size())
              {
                throw runtime_exception(exception_type::RUNTIME_ERROR, CPPTRANSPORT_PRODUCT_DATALINE_AXIS_MISMATCH);
              }

            if(type == data_storage_type::raw)
              {
                data = this->zip(a, d);
                y_type = vt;
                return;
              }

            // zip x- and y-axis values together to ensure they are sorted in ascending order - the spline
            // functions assume this to be the case
            auto zipped = this->zip(a, d);

            std::vector<double> new_axis(a.size());
            std::vector<number> new_data(d.size());

            for(unsigned int i = 0; i < zipped.size(); ++i)
              {
                new_axis[i] = zipped[i].first;
                new_data[i] = zipped[i].second;
              }

            try
              {
                spline1d<number> spline(new_axis, new_data);

                switch(type)
                  {
                    case data_storage_type::splined:
                      {
                        // compute logarithmic derivative at each axis point
                        for(unsigned int i = 0; i < new_axis.size(); ++i)
                          {
                            number value = spline.eval(new_axis[i]);
                            new_data[i] = value;
                          }
                        y_type = vt;
                        break;
                      }

                    case data_storage_type::derivative:
                      {
                        // compute logarithmic derivative at each axis point
                        for(unsigned int i = 0; i < new_axis.size(); ++i)
                          {
                            number value = spline.eval_diff(new_axis[i]);
                            new_data[i] = value;
                          }
                        // TODO: work out what type to put here.
                        y_type = vt;
                        break;
                      }

                    case data_storage_type::spectral_index:
                      {
                        // compute logarithmic derivative at each axis point
                        for(unsigned int i = 0; i < new_axis.size(); ++i)
                          {
                            number value = spline.eval_diff(new_axis[i]) * (new_axis[i]/new_data[i]);
                            new_data[i] = value;
                          }
                        y_type = value_type::spectral_index;
                        break;
                      }

                    default:
                      {
                        throw runtime_exception(exception_type::RUNTIME_ERROR, CPPTRANSPORT_PRODUCT_DATALINE_UNEXPECTED_STORE);
                      }
                  }

                data = this->zip(new_axis, new_data);
              }
            catch(runtime_exception& xe)
              {
                if(xe.get_exception_code() == exception_type::SPLINE_ERROR)
                  {
                    std::ostringstream msg;

                    msg << CPPTRANSPORT_PRODUCT_CANT_BUILD_SPLINE_A << " '" << nLl << "' "
                        << CPPTRANSPORT_PRODUCT_CANT_BUILD_SPLINE_B;
                    this->messages.push_back(msg.str());
//		                    std::cout << "** SPLINE ERROR: axis data" << '\n';
//				                for(unsigned int i = 0; i < a.size(); ++i)
//					                {
//				                    std::cout << i << ". x=" << a[i] << ", y=" << d[i] << '\n';
//					                }
//		                    std::cout << "** LaTeX label = " << Ll << ", non-LaTeX label = " << nLl << '\n';

                    data = this->zip(a, d);
                  }
                else throw;
              }
          }


        namespace data_line_impl
          {

            template <typename number>
            struct AxisSorter
              {
                bool operator()(const std::pair<double, number>& a, const std::pair<double, number>& b)
                  {
                    return (a.first < b.first);
                  }
              };

          }   // namespace data_line_impl


        template <typename number>
        typename data_line<number>::point_list
        data_line<number>::zip(const std::vector<double>& a, const std::vector<number>& d)
          {
            point_list zipped;
            zipped.reserve(a.size());

            // push data points onto the axis
            for(unsigned int i = 0; i < a.size(); ++i)
	            {
                zipped.push_back(std::make_pair(a[i], d[i]));
	            }

            // now sort axis into ascending order
            std::sort(zipped.begin(), zipped.end(), data_line_impl::AxisSorter<number>());

            return zipped;
	        }


        template <typename number, typename DataContainer, typename GroupSet>
        data_line_set<number>
        time_data_line_factory(const DataContainer& container, GroupSet g, axis_value at, value_type vt,
                               const std::vector<double>& a, const std::vector<number>& d, std::string Ll,
                               std::string nLl, slave_message_buffer& msg)
          {
            return data_line_set<number>{ {std::move(g), at, vt, a, d, std::move(Ll), std::move(nLl), msg,
                                           data_storage_type::raw} };
          }


        template <typename number, typename DataContainer, typename GroupSet>
        void
        time_data_line_factory(const DataContainer& container, data_line_set<number>& lines, GroupSet g,
                               axis_value at, value_type vt, const std::vector<double>& a, const std::vector<number>& d,
                               std::string Ll, std::string nLl, slave_message_buffer& msg)
          {
            lines.emplace_back(std::move(g), at, vt, a, d, std::move(Ll), std::move(nLl), msg, data_storage_type::raw);
          }


        template <typename number, typename DataContainer, typename GroupSet>
        void
        wavenumber_data_line_factory(const DataContainer& container, data_line_set<number>& lines,
                                     GroupSet g, axis_value at, value_type vt,
                                     const std::vector<double>& a, const std::vector<number>& d,
                                     std::string Ll, std::string nLl, slave_message_buffer& msg)
          {
            bool is_spectral = container.is_spectral_index();
            data_storage_type what = is_spectral ? data_storage_type::spectral_index
                                                 : data_storage_type::raw;

            value_type type = is_spectral ? vt : value_type::spectral_index;

            if(is_spectral)
              {
                Ll += " ";
                Ll += CPPTRANSPORT_LATEX_SPECTRAL_INDEX;

                nLl += " ";
                nLl += CPPTRANSPORT_NONLATEX_SPECTRAL_INDEX;
              }

            lines.emplace_back(std::move(g), at, type, a, d, std::move(Ll), std::move(nLl), msg, what);
          }


      }   // namespace derived_data

  }   // namespace transport


#endif //CPPTRANSPORT_DATA_LINE_H
